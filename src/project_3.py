# -*- coding: utf-8 -*-
"""project 3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ot6_uzl3PxB5fGbtVGcbSfqZpqhVdlBu

Patient utility class- Darren
"""

from abc import ABC, abstractmethod

class BasePatient(ABC):
    def __init__(self, patient_dict=None, patient_logs=None):
        self.patient_dict = patient_dict or {}
        self.patient_logs = patient_logs or []

    @abstractmethod
    def process(self):
        pass


class PatientVitals(BasePatient):
    def __init__(self, patient_dict=None, weight_kg=None, height_m=None):
        super().__init__(patient_dict)
        self.weight_kg = weight_kg
        self.height_m = height_m

    def process(self):
        return self.bmi_calculator()

    def bmi_calculator(self):
        if self.height_m <= 0 or self.weight_kg <= 0:
            raise ValueError("Height and weight must be positive numbers.")
        bmi = self.weight_kg / (self.height_m ** 2)
        category = (
            "Underweight" if bmi < 18.5 else
            "Normal weight" if bmi < 25 else
            "Overweight" if bmi < 30 else
            "Obese"
        )
        return round(bmi, 1), category


class PatientProfile(BasePatient):
    def process(self):
        return self.patient_summary()

    def patient_summary(self):
        try:
            return f"{self.patient_dict['firstname'].title()} {self.patient_dict['lastname'].title()} " \
                   f"(patient ID: {self.patient_dict['patientid']}) - Severity: {self.patient_dict['severity'].capitalize()}, " \
                   f"Symptoms: {' , '.join(self.patient_dict['symptoms'])}"
        except KeyError:
            raise ValueError("Invalid patient dictionary format.")

    def allergy_alert(self):
        allergies = self.patient_dict.get('allergies', [])
        return f"⚠️ Allergy Alert: {' , '.join(allergies)}" if allergies else "No known allergies."


class PatientLogs(BasePatient):
    def process(self):
        return self.average_symptom_duration()

    def average_symptom_duration(self):
        durations = [p['duration_days'] for p in self.patient_logs if 'duration_days' in p]
        return sum(durations) / len(durations) if durations else 0

# src/domain.py
from __future__ import annotations
from dataclasses import dataclass, field
from datetime import date, datetime, timedelta
from typing import List, Dict, Iterable, Tuple
from abc import ABC, abstractmethod
from collections import Counter
import re


# 1) Inheritance Hierarchy


class PatientProfile(ABC):
    """
    Abstract base for all patient profiles.
    Enforces a common interface for risk and follow-up behavior.
    """

    def __init__(
        self,
        patient_id: str,
        first_name: str,
        last_name: str,
        dob: date,
        symptoms: List[str],
        severity: int,            # 0–10
        visits: int,
        allergies: List[str],
    ) -> None:
        self.patient_id = patient_id
        self.first_name = first_name
        self.last_name = last_name
        self.dob = dob
        self.symptoms = [s.strip().lower() for s in symptoms]
        self.severity = severity
        self.visits = int(visits)
        self.allergies = [a.strip().lower() for a in allergies]

    #  Polymorphic interface
    @abstractmethod
    def follow_up_window_days(self) -> int:
        """When should this cohort be followed up next (days)?"""
        raise NotImplementedError

    def _base_risk(self) -> float:
        """
        Shared baseline: severity (0–10) + symptom burden + recent utilization proxy.
        Subclasses can scale/adjust this via super().
        """
        symptom_burden = min(5, len(set(self.symptoms)))       # cap a bit to avoid runaway
        utilization = min(5, self.visits // 3)                 # every ~3 visits adds 1
        return float(self.severity) + symptom_burden + utilization

    def risk_score(self) -> float:
        """
        Default risk score; subclasses can override and call super().risk_score()
        to apply cohort-specific multipliers.
        """
        return self._base_risk()

class PediatricPatient(PatientProfile):
    def follow_up_window_days(self) -> int:
        return 7

    def risk_score(self) -> float:
        # kids generally lower mortality risk but higher escalation vigilance; slight downscale
        return super().risk_score() * 0.9

class AdultPatient(PatientProfile):
    def follow_up_window_days(self) -> int:
        return 14

    # inherits default risk_score()

class GeriatricPatient(PatientProfile):
    def follow_up_window_days(self) -> int:
        return 7

    def risk_score(self) -> float:
        # geriatrics often have higher compound risk; scale up using super()
        return super().risk_score() * 1.3


# 2) Composition


@dataclass
class Registry:
    """Holds patients; pure composition (the registry *has* many patients)."""
    patients: Dict[str, PatientProfile] = field(default_factory=dict)

    def add(self, patient: PatientProfile) -> None:
        self.patients[patient.patient_id] = patient

    def get(self, patient_id: str) -> PatientProfile:
        return self.patients[patient_id]

    def all(self) -> Iterable[PatientProfile]:
        return self.patients.values()


# 3) ABC for Analyzers


class AbstractAnalyzer(ABC):
    """Analyzer ABC enforcing a common analyze() interface."""

    @abstractmethod
    def analyze(self, patients: Iterable[PatientProfile]) -> dict:
        """Return structured analytics given any cohort of PatientProfile objects."""
        raise NotImplementedError

# Concrete analyzers demonstrating polymorphism over base PatientProfile

class SymptomAnalyzer(AbstractAnalyzer):
    """Counts top symptom combinations; mirrors your 'top_ranked_searches' idea."""
    def __init__(self, top_n: int = 10) -> None:
        self.top_n = top_n

    def analyze(self, patients: Iterable[PatientProfile]) -> dict:
        counts: Counter[Tuple[str, ...]] = Counter()
        for p in patients:
            if p.symptoms:
                combo = tuple(sorted(set(p.symptoms)))
                counts[combo] += 1
        return {"top_symptom_sets": counts.most_common(self.top_n)}

class AllergyConflictAnalyzer(AbstractAnalyzer):
    """Detects potential conflicts between allergies and a medication list."""
    def __init__(self, medication_list: List[str]) -> None:
        self.meds = [m.lower() for m in medication_list]

    def _has_conflict(self, allergies: List[str]) -> bool:
        meds = self.meds
        for allergy in (a.lower() for a in allergies):
            for med in meds:
                # same logic family as your original: case insensitive, partial heuristics
                if allergy in med or med.startswith(allergy[:4]) or med.endswith(allergy[-4:]):
                    return True
        return False

    def analyze(self, patients: Iterable[PatientProfile]) -> dict:
        conflicts = []
        for p in patients:
            if self._has_conflict(p.allergies):
                conflicts.append(p.patient_id)
        return {"conflicting_patient_ids": conflicts}

class RiskAnalyzer(AbstractAnalyzer):
    """Ranks patients by polymorphic risk_score() and proposes follow-up windows."""
    def __init__(self, top_n: int = 10) -> None:
        self.top_n = top_n

    def analyze(self, patients: Iterable[PatientProfile]) -> dict:
        ranked = sorted(
            ((p.patient_id, p.risk_score(), p.follow_up_window_days()) for p in patients),
            key=lambda t: t[1],
            reverse=True,
        )
        return {"ranked_risk": ranked[: self.top_n]}


# 4) Engine composition


@dataclass
class AnalyticsEngine:
    """Engine composed of multiple analyzers. It *has* analyzers; it does not inherit from them."""
    analyzers: List[AbstractAnalyzer] = field(default_factory=list)

    def run(self, patients: Iterable[PatientProfile]) -> Dict[str, dict]:
        results: Dict[str, dict] = {}
        for analyzer in self.analyzers:
            key = analyzer.__class__.__name__
            results[key] = analyzer.analyze(patients)  # polymorphic dispatch
        return results

# 5) Utility: year extraction (kept for convenience)


def extract_year(value) -> int | None:
    """Extract a 4-digit year from text, token, or numeric input."""
    if isinstance(value, int):
        return value if 1800 <= value <= datetime.now().year else None
    if not isinstance(value, str):
        return None
    match = re.search(r"(19|20)\d{2}", value)
    return int(match.group()) if match else None

"""Patient analytics test - Chimezia"""

# tests/test_domain.py
from datetime import date
import pytest
from src.domain import (
    PatientProfile, PediatricPatient, AdultPatient, GeriatricPatient,
    Registry, SymptomAnalyzer, AllergyConflictAnalyzer, RiskAnalyzer,
    AnalyticsEngine, extract_year
)

def mk_patients():
    p1 = PediatricPatient("p1", "Ada", "L.", date(2018, 5, 1), ["fever","cough"], 6, 2, ["penicillin"])
    p2 = AdultPatient("p2", "Ben", "J.", date(1990, 3, 2), ["headache","nausea","dizziness"], 5, 6, ["aspirin"])
    p3 = GeriatricPatient("p3", "Cia", "K.", date(1945, 7, 9), ["fatigue"], 7, 10, ["sulfa"])
    return [p1, p2, p3]

def test_abc_enforcement():
    class Bad(PatientProfile):
        # forget to implement follow_up_window_days()
        pass
    with pytest.raises(TypeError):
        Bad("x","a","b", date(2000,1,1), [], 0, 0, [])

def test_polymorphic_follow_up_and_risk():
    p1, p2, p3 = mk_patients()
    # follow-up windows differ by subclass
    assert p1.follow_up_window_days() == 7
    assert p2.follow_up_window_days() == 14
    assert p3.follow_up_window_days() == 7
    # risk shows subclass scaling via super()
    assert p1.risk_score() < p2.risk_score() < p3.risk_score()

def test_composition_registry_and_engine():
    reg = Registry()
    for p in mk_patients():
        reg.add(p)
    engine = AnalyticsEngine([
        SymptomAnalyzer(top_n=5),
        RiskAnalyzer(top_n=3),
        AllergyConflictAnalyzer(medication_list=["Penicillin V", "Aspirin 81mg"])
    ])
    results = engine.run(reg.all())
    assert "SymptomAnalyzer" in results
    assert "RiskAnalyzer" in results
    assert "AllergyConflictAnalyzer" in results
    assert len(results["RiskAnalyzer"]["ranked_risk"]) == 3
    # p1 and p2 should conflict with meds
    ids = set(results["AllergyConflictAnalyzer"]["conflicting_patient_ids"])
    assert {"p1","p2"}.issubset(ids)

def test_extract_year():
    assert extract_year("DOB: 1999-07-04") == 1999
    assert extract_year(2005) == 2005
    assert extract_year("no year") is None

"""Readme section - Patient analytics

Overview

Goal: Analyze patient data (symptoms, allergies, risk, follow-up) with clean OOP design.

Inheritance

PatientProfile(ABC) → PediatricPatient, AdultPatient, GeriatricPatient.
Rationale: real is-a relationship (all share risk + follow-up interface).
Depth kept to one level; subclasses override follow_up_window_days() and (optionally) risk_score().

Polymorphism

AnalyticsEngine.run() accepts Iterable[PatientProfile] and calls risk_score()/follow_up_window_days() with dynamic dispatch.

AbstractAnalyzer(ABC) → SymptomAnalyzer, AllergyConflictAnalyzer, RiskAnalyzer; engine calls analyze() polymorphically.
Composition vs Inheritance
Registry has patients (composition) — not a kind of patient.

AnalyticsEngine has analyzers — avoids deep inheritance trees; analyzers can be swapped (Strategy-like).
Loan equivalent not needed; conflicts and risk computed from owned data.

Design Patterns

Strategy flavor: pluggable analyzers.
Template Method vibe: PatientProfile._base_risk() with subclass scaling via super().

Extensibility

Add OncologyPatient with chemo-specific risk logic; add UtilizationAnalyzer without touching existing analyzers.

class diagram - patient analytics

PatientProfile (ABC)
 ├─ PediatricPatient
 ├─ AdultPatient
 └─ GeriatricPatient

Registry ──has many──► PatientProfile
AnalyticsEngine ──has many──► AbstractAnalyzer
AbstractAnalyzer (ABC)
 ├─ SymptomAnalyzer
 ├─ AllergyConflictAnalyzer
 └─ RiskAnalyzer

usage - patient analytics
"""

from datetime import date
from src.domain import *

reg = Registry()
reg.add(AdultPatient("p2","Ben","J.", date(1990,3,2), ["headache","nausea"], 5, 6, ["aspirin"]))

engine = AnalyticsEngine([RiskAnalyzer(), SymptomAnalyzer(), AllergyConflictAnalyzer(["Aspirin"])])
print(engine.run(reg.all()))

"""Doctor utility class - Tatiana"""

from abc import ABC, abstractmethod

# abstract base class
class MedicalStaff(ABC):
    """Abstract base class representing general medical staff."""

    def __init__(self, staff_id: str, first_name: str, last_name: str):
        if not staff_id or not first_name or not last_name:
            raise ValueError("ID, first name, and last name are required")

        self._staff_id = staff_id
        self._first_name = first_name
        self._last_name = last_name

    @property
    def full_name(self):
        return f"{self._first_name} {self._last_name}"

    @property
    def staff_id(self):
        return self._staff_id

    @abstractmethod
    def calculate_daily_tasks(self):
        """Polymorphic method – implemented differently by each subclass"""
        pass

    def display_info(self):
        """Common display logic."""
        print(f"Name      : {self.full_name}")
        print(f"Staff ID  : {self._staff_id}")

    def __str__(self):
        return f"{self.full_name} (ID: {self._staff_id})"


#2 inheritance hierarchy - extends medicalstaff
class Doctor(MedicalStaff):
    """Represents a doctor in the system."""

    def calculate_daily_tasks(self):
        return ["Review patient charts", "Conduct appointments", "Prescribe medications"]

    def display_info(self):
        """Overrides base method, uses super() to extend functionality."""
        print("Doctor Information")
        print("-" * 25)
        super().display_info()  # Call shared logic
        print("Role      : Doctor\n")


# additional nurse subclass
class Nurse(MedicalStaff):
    """Represents a nurse in the system."""

    def calculate_daily_tasks(self):
        return ["Take vitals", "Prepare exam rooms", "Assist doctors", "Update records"]

    def display_info(self):
        print("Nurse Information")
        print("-" * 25)
        super().display_info()
        print("Role      : Nurse\n")

# derived class from doctor
class Surgeon(Doctor):
    """Specialized doctor with surgical responsibilities."""

    def calculate_daily_tasks(self):
        # Override Doctor’s version entirely
        return ["Perform surgeries", "Conduct pre-op evaluations", "Post-op monitoring"]

    def display_info(self):
        print("Surgeon Information")
        print("-" * 25)
        super().display_info()  # Call Doctor’s display, which calls MedicalStaff.display
        print("Specialty : Surgery\n")


#4 - department has staff members
class HospitalDepartment:
    """
    Represents a hospital department using COMPOSITION:
    - A department HAS medical staff.
    """

    def __init__(self, name: str):
        self.name = name
        self.staff_members: list[MedicalStaff] = []  # Composition

    def add_staff(self, staff: MedicalStaff):
        """Department contains staff—polymorphic arguments allowed."""
        self.staff_members.append(staff)

    def list_staff(self):
        print(f"\nDepartment: {self.name}")
        print("Staff Members:")
        print("-" * 40)
        for member in self.staff_members:
            print(member)  # polymorphic __str__()

    def show_all_daily_tasks(self):
        """Demonstrates polymorphism."""
        print(f"\nDaily Tasks for {self.name} Department")
        print("-" * 40)
        for member in self.staff_members:
            print(f"{member.full_name}:")
            for task in member.calculate_daily_tasks():  # polymorphic!
                print(f"  - {task}")
            print()

"""Abstract Base Class"""

class MedicalStaff(ABC):
    @abstractmethod
    def calculate_daily_tasks(self):
        pass